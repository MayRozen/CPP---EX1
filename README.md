בס"ד

מטלה 1 - תכנות מערכות 2:

המטלה מורכת למעשה משני חלקים. חלק הראשון הוא החלק המתעסק בבניית האובייקט "Graph" ובמימוש האלגוריתמים שניתן למעשה לבצע עליו. החלק השני, לעומת זאת, מתעסק בביצוע טסטים על מנת לוודא כי מה שבנינו אכן עובד כפי שאנחנו רוצים ומצפים.
תחילה אפרט על החלק הראשון ולאחר מכן אעבור לחלק השני.

חלק 1 - 
מימוש Graph:
את Graph בניתי כאובייקט שנמצא תחת namespace ariel. משום שזהו אובייקט אזי יש לו class Graph.
כמו כן, את השדות שלו הגדרתי כ - private ויצרתי עבורם פונקצית get(). זאת כדי ליצור אנקפסולציה ולשמר על "מידור מידע" בין הקבצים.
נשים לב שבפונקציות get, אנו קולטים לפונ' את g כמשתנה const. הרי אנחנו לא משנים את שדותיו ולכן אין צורך בהגדרה שונה מכך.
בנוסף, יצרתי בנאי שיודע ליצור עבורינו גרף ריק שלאחריו נוכל להכניס לאותו הגרף את הערכים שלו (מספר הקודקודים שהגרף מכיל ומטריצת השכנויות המייצגת אותו).

מימוש Algorithms:
את Algorithms מימשתי כ - namespace ולא כ - class. זאת משום שתפקידו של קובץ זה הוא לבצע פעולות שונות על אובייקט מסוג Graph. אך הוא אינו מכיל או מייצר אובייקטים משל עצמו.
כלומר, זהו קובץ המכיל מתודות שניתן לבצע על Graph.
בנוסף, נשים לב שרוב הפונקציות יקבלו את Graph g כ - const (כי הרי אנחנו לא ניגשים לשדות שלו ומשנים אותן) וכן הן יקבלו אותו כ - reference: Graph &g. זאת על מנת לדייק ולעבוד מול האובייקט המקורי ולא מול העתק.

כעת אפרט על המימושים של האלגוריתמים עצמם:
    bool isConnected(Graph &g);
על מנת לבדוק האם הגרף קשיר עלינו לבדוק כי אכן יש לנו "דרך" להגיע מכול קודקוד לכל קודקוד. לשם כך, נעזרתי באלגוריתם DFS עליו למדנו בקורס אלגוריתמים 1. בכול קודקוד עליו "דרכנו" הכנסתי ערך "True". כך לבסוף, בעת סיום הריצה של האלגוריתם, במידה וכל הקודקודים מכילים ערך "True" אזי אפשר לדעת שאכן הגענו לכל הקודקודים. כלומר, אכן קיימת דרך כנ"ל ומדובר בגרף קשיר.


    std::vector<int> shortestPath(const Graph &g,IndexType start,IndexType end);
על מנת למצוא את הדרך הכי קצרה בין שני קודקודים בגרף נעזרתי באלגוריתם Dijkstra עליו למדנו בקורס אלגוריתמים 1. בעזרתו ניתן למצוא את הדרך הקצרה ביותר בין שני קודקודים בגרף (לא אפרט על המימוש משום שמסופקות הערות מפורטות בקוד).

    int isContainsCycle(const Graph &g);
כדי לבדוק האם קיים מעגל בגרף נעזרתי באלגוריתם Bellman-ford אשר גם עליו למדנו במהלך הסמסטר הקודם. אלגוריתם זה ידוע כאלגוריתם יעיל מאוד עבור גרף המכיל גם צלעות שליליות (בהנחה ואכן זה קיים כאן אצלינו). הוא מבצע פעולה הנקראת "relax" על כל צלעות הגרף n-1 פעמים על כל צלע (כאשר מדובר ב - n קודקודים לגרף). פעולה זה משווה בכול פעם האם הוספת הצלע אשר אנחנו עומדים עליה מקנה לנו מסלול קצר יותר מהמסלול אותו "הצלחנו לחשוף" עד כה. במידה וכן - ניקח את צלע זו ונעדכן את המסלול הקצר ביותר.
המיוחד באלגוריתם זה הוא שבעת הרצת פעולת ה - relax פעם נוספת, ניתן לבחון האם סכום הצלעות עלה או ירד מעבר למצופה ולא נשאר זהה למה שהיה קודם. דבר שיכול לקרות רק במקרה בו יש מעגל חיובי או שלילי.
כלומר, כך בידינו היכולת לזהות מעגל וזה בדיוק מה שביצענו כאן.

    int isBipartite(const Graph &g);
ראשית, נשים לב שגרף לא יכול להיות דו צדדי במידה והוא מכיל מעגל. לכן, לפני כתיבת שאר המתודה, בדקתי תחילה שאין מעגל בגרף.
לאחר מכן, נעזרתי באלגוריתם שנקרא "אלגוריתם צביעת הגרף" (Graph Coloring Algorithm) שמטרתו לעבור על קודקודי הגרף ולצבוע כל קבוצת קודקודים בצבע שונה. כל קבוצה מוגדרת כך שאין בה קשתות פנימיות (בין צומת בתוך אותה הקבוצה לצומת אחרת בתוך הקבוצה), אלא כאשר מתוך ק' בקבוצה זו קיימת קשת לק' בקבוצה השנייה. כמו כן, לאחר שצומת נצבע בצבע מסוים, האלגוריתם בודק את כל צמתיו ומוודא שאין צומת אחד שהוא מחובר אליו שכבר צבוע באותו הצבע. אם נמצא כזה, זה אומר שהגרף אינו דו-צדדי, כיוון שיש קשת המחברת בין שני צמתים שצבועים באותו הצבע.
בסיום הצביעה, אם לא נמצאה צביעה זהה של שני צמתים שמתוך הם ישנה קשת, אז הגרף מתקיים את התנאים של גרף דו-צדדי.

    std::vector<int> negativeCycle(const Graph &g);
על מנת לבדוק האם קיים מעגל שלילי נעזרתי באלגרויתם Bellman-ford עליו כבר פירטתי לעיל.

חלק 2 - 


